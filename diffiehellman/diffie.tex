\section{ADFGVX}
\subsection{De opdracht}
De opdracht rond Diffie-Hellman bestond uit twee delen: ten eerste het berekenen van de gezamelijke sleutel en ten tweede het achterhalen van de titels waaruit de geheime sleutels gegenereerd werden.

\subsection{Gezamelijke sleutel: eerste pogingen}
...index calculus, priemontbinding, blabla...

We hebben ook overwogen om met een lijst van titels de sleutels proberen te achterhalen, maar dit was onbegonnen werk aangezien niets geweten was over taal, soort boek, gebruik van hoofdletters en speciale tekens, spaties, ...

\subsection{Gezamelijke sleutel: Pohlig-Hellman}
We stapten vervolgens over op het Pohlig-Hellman algoritme. Dit is in theorie trager dan index calculus, maar veel makkelijker te implementeren. Pohlig-Hellman is namelijk veel makkelijker om volledig automatisch te laten verlopen; het bevat geen vage en lastig te implementeren stappen als "kies een aantal kleine priemgetallen". Ook hoeft slechts van \'e\'en getal de priemontbinding berekend te worden, terwijl dit bij index calculus elke stap gebeurt. We berekenden de priemontbinding van $p-1$ met Wolfram-Alpha. Gezien vele wiskundige pakketten ingebouwde functies hiervoor hebben, vonden we het niet nodig dit met eigen code te berekenen. We hadden hiervoor wel code, alleen werkte deze verschrikkelijk traag.  \\Pohlig-Hellman werkt het snelst met kleine priemfactoren. De grootste priemfactor was $60432007$, wat niet restrictief groot bleek te zijn.  \\ Het algoritme implementeerden we wel helemaal zelf in Python. We baseerden ons op \href{https://www.youtube.com/watch?v=BXFNYVmdtJU}{deze uitleg} van het algoritme. Eerst berekenden we, met inputs de gegeven $A$, $g$ en $p$, voor elke priemfactor $p_i$ (of macht van priemfactor, bij meermaals voorkomende factoren) een $a_i$ zodat $a \equiv a_i (mod\ p_i)$. Hieruit haalden we dan $a\ mod \ (p-1)$ via de Chinese reststelling. Daarna draaiden we het algoritme opnieuw met $B$ om $b$ te bepalen. Gezien voor elke $a_i$ tot $p_i$ mogelijke waardes met trial and error geprobeerd moeten worden, kan het algoritme makkelijk een tiental uur nodig hebben om een resultaat te vinden. We versnelden dit enigszins door het algoritme enkele keren naast elkaar te draaien en verschillende waarden te laten testen. Enkel $a$ of $b$ is voldoende om de gezamelijke sleutel te bepalen, maar we bepaalden ze allebei om ons resultaat te verifi\"eren en omdat we ze toch nodig hebben voor het tweede deel van de opdracht.

\subsection{De titels}
Tsja.
