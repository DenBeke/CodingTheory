package main

//import "os"
import "fmt"

import "github.com/DenBeke/CodingTheory/enigma"

//import "runtime"
//import "github.com/davecheney/profile"

func main() {

	//defer profile.Start(profile.CPUProfile).Stop()

	//runtime.GOMAXPROCS(runtime.NumCPU())

	/*
		if len(os.Args) == 1 {
			println("Usage:", os.Args[0], "input.json")
			return
		}

		enigma_config, err := enigma.ReadConfig(os.Args[1])

		if err != nil {
			println("Error:", err)

		}

		fmt.Println(enigma_config)
		e := enigma_config.CreateEnigma()
		encoded := e.Encode("TEST", "AAA")
		fmt.Printf("%q \n", encoded)
		fmt.Printf("Finished encoding \n")
	*/

	//defer profile.Start(profile.CPUProfile).Stop()

	//runtime.GOMAXPROCS(runtime.NumCPU())

	/*if len(os.Args) == 1 {
		println("Usage:", os.Args[0], "input.json")
		return
	}

	enigma_config, err := enigma.ReadConfig(os.Args[1])

	if err != nil {
		println("Error:", err)

	}
	fmt.Println(enigma_config)
	e := enigma_config.CreateEnigma(rotors)
	encoded := e.Encode("XXXXXXXXXXXXB", "AAA")
	fmt.Printf("%q \n", encoded)
	fmt.Printf("Finished encoding \n")*/

	/**
	 * THE FOLLOWING CODE IS USED TO CRACK THE ENIGMA CIPHER
	 * ONLY HAVE ONE OF THE THREE BLOCKS UNCOMMENTED FOR THE CODE TO RUN
	 * THE FIRST LINE BELOW THIS COMMENT IS NEEDED FOR EACH OF THE THREE BLOCKS
	 */
	enigma_config, _ := enigma.ReadConfig("jsonConfigFiles/assignment.json")

	/**
	 * Use this block to determine the rotor setup and settings for the cipher
	 * Uncomment one of the closedPaths to test for that path
	 * The valid setting-letter pairs will be printed
	 * This way one plugboard setting can also be found
	 */

	rs := enigma.MakeRotorSetup()
	//Uncomment any one of these closed path lists to test for node in the crib graph
	//closedPaths := [][]int{{6,32,12,1},{6,32,12,17,21},{6,32,12,18,21},{13,0,2,14,12,1},{13,3,30,23,26,4,7,6},{29,5,32,16,27,0,3,31,9,22,10}} // FOR I
	//closedPaths := [][]int{{16,14,32},{16,27,0,24},{16,2,0,13,6},{32,5,29,6},{7,15,25,18,12,32}} //FOR A
	//closedPaths := [][]int{{17,18},{17,1,21},{18,12,32,6,21},{25,15,7,32,12,18},{21,10,22,9,31,30,23,26,4,7,32,12,17},{17,12,32,16,2,0,13,21}} //FOR U
	closedPaths := [][]int{{5,29,6,32},{32,7,4,26,23,30,3,13,1,12},{12,1,13,0,2,14},{14,16,32},{12,17,25,15,7,32}} //FOR D
	for i := 0; i < 60; i++ {
		setup := rs.GetNext()
		fmt.Println("Setup ", i, ": ", setup)
		e := enigma_config.CreateEnigma(setup)
		e.GetFix(closedPaths)
	}

	/**
	 * Use this block to determine the plugboard setting for a letter
	 * after getting the rotor setup and settings
	 * Uncomment one of the closedPaths to test for that path
	 * The valid setting-letter pairs will be printed
	 * This way the mapping for the tested letter can be found
	 */

	/*setup := [3]int{4,2,0}
	fmt.Println("Setup: " , setup)
	e := enigma_config.CreateEnigma(setup)
	//Uncomment any one of these closed path lists to test for node in the crib graph
	//Note that the lists are shorter here as we're only testing for one setting.
	//The existence of hits for other settings doesn't matter in this case
	closedPaths := [][]int{{26,4,7,32,12,17,21,10,22,9,31,30,23},{23,30,3,24,7,4,26},{23,30,3,13,6,7,4,26}} //FOR C
	//closedPaths := [][]int{{26,23,30,3,13,29,5,32,7,4},{4,7,16,2,0,3,30,23,26}} //FOR F
	//closedPaths := [][]int{{23,26,4,7,32,12,17,21,10,22,9,31,30},{30,3,13,29,5,32,7,4,26,23}} //FOR G
	//closedPaths := [][]int{{0,2,16,24},{13,6,24},{3,30,23,26,4,7,24}} //FOR K
	//closedPaths := [][]int {{3,13,29,5,32,7,4,26,23,30},{31,9,22,10,21,25,15,4,26,23,30}} //FOR L
	//closedPaths := [][]int {{9,22,10,21,25,15,4,26,23,30,31},{31,3,13,10,22,9}} //FOR M
	//closedPaths := [][]int {{22,10,21,25,15,4,26,23,30,31,9},{9,31,3,13,10,22}} //FOR N
	//closedPaths := [][]int {{25,21,10,22,9,31,30,23,26,4,15},{15,7,32,12,17,25}} //FOR O
	//closedPaths := [][]int {{5,12,17,21,29},{29,13,24,32,5}} //FOR P
	//closedPaths := [][]int {{1,6,32,12},{17,21,1},{12,5,29,1}} //FOR R
	//closedPaths := [][]int {{7,32,12,17,25,15},{15,25,21,6,7}} //FOR S
	//closedPaths := [][]int{{2,27},{0,24,16,2},{2,14,12,1,13,0}} //FOR V
	e.GetFixSpecific(closedPaths)*/

	/**
	 * Use this block to decipher the entire ciphertext after determining
	 * rotor setup and settings and plugboard settings
	 */

	setup := [3]int{4, 2, 0}
	e := enigma_config.CreateEnigma(setup)
	cipherText := "KRVKFDIATNHZRKDOAURJTIHCKOCVYPLLDVGVYMUFQBQOKLOUCARCDKDFYODGGBLZSKMDBOQRYYJNRXFZEMABTJBSCSUKJCZSLEKYBAFOFRDIPZPDYJLOVYTJEERJOLTDFWVRVBVJXSOPXTUWWKLVVCGNROQANPCAAJRRZHZZNZXUSZWWASMBWBKIMYNGLXHLBHDUXHZXKDYVCOYDJLNJAXSWHPTKLUAYTVENAUOAVZXLSPQEOSJZIPSEXWUBYJDDPCTIWDQCWBSDQSUPVWTLGKLYWYSTUTXZEWVXFUQUYWWPQRWUAMSVAMDJYNXRWMWXOPOQNZGIPMVBKHZHYCVAVABFMCHZCJUSSOAJHGHRCASWLQCVOCLLSNBOXWJNJQZGVDOBRQAAYWKACXNQMXQIMZTFJZWOZSCGGDYRKHLVDBUZYKKFXFMZJJAZAMCGUBDPGVMOVEJAYKFADJKRXUSOYBQYZUZGXGQEVIATXLYKNYNZQILQWOTDIKMWPIBVVQLUOWZEENVVYIMZOIPHXLKFOZQVRIOZYBLLVDHWBFPYKAOCQVOSURSCUQXFKSRQFHBZQXXCPMXFYVPHLWVGUELRNZQRDNOMYLSOJRZUKSYSPEVVWWBYABXTBGUEWTCWYERYMUWFJNCEQHFNODXGHJMEBRGDYGHAUJHIXMMKLUROGFTMSTVIFWLQBPOWSZXUPYCTMRMVUMXCCEOHHDJTCDJWQYKQJCXJSKVOCUMIUIXABEKAVIZEFSGJFCJWCPRTUGVQLULMAHJXWDTVGKYLJVUMTFCTQJZSTMVQIGIIMGFJOLXKULWMZSKBCRJZNIXXWMDTFTAJQZOFWXQAAMMTDVYBKWWSIWCCBXFYISMKRMFOSEQQRFQDQXYAFHEDXTFZBXOADZFMRJGUODBBWIXZMCIGHJPZVSVZBDLASAURSRLHXASHBCNONZNLUBXPEFPNRRHBAXDMUDMWMMCNZQTMYKBIUSAPLSLURTLAFGCVOCZLAXFVXKUFFXTBBUNFAQFFWVMCDABXKJOEAXUZXHAVRVYASDYXEJPOMDFICNFPMTIWMJPHFBNDHPGQPLBQZEEQTZNJTXHQEQESJOTNPFFUKZPXUJCTLMLGVCRPMSXFBYOKSCVXUGZHSSAVCQYGZDHKZPYSSGTCEJKGBDSQUZXSMRZHDZOLMIGOADKMPUMWGFNPVLVNLJOQSXHQYVOZUYSYQHYZWXEPVUTTNZCGTFBQOLOKSIJNFRTXOAEFQXXYOWDUYKTXWEABJJXKMXNWKUDDXTLVDGEQBYPXCUBTRNVJOHGNQBTUGHBOLNNXUABVPWKQDWFKHDUEILXANSJFJUIBCBHBFFEKLQPGAXUVUOOVZTGJWKLBJOTALGDUIFHPIXAOJAVVYQVLARSNEGWRNHICNISVDQVZOLHQIIXHXTMHCVEHERLIKFHNUFGCLYKELRWYXHGGGIUOESNHCSGOFGQLHWPJBFXGGOLMCIBVNKGMURBWNVFAWBKYESVBIGKAWYDLEMOUNJNSGEJOBDBTUMVNIWEAVAYZLQGVDNYFTSUDODOUDRZEOPWXBLORZEWXDFCKXWOYERGRDWPREPINPTMZTQUASGVQSESFPNCYPFSNYIFNROAUUALWVQGBEWGJZAIPFPRCUVBKKLJBUKIVDMZSZIDKQGVYBRWFFYPLFWBSBMWKYFDJVLMYISOMWTNCMXXOTUXKWMQEDUDGWJLLWEHOTRGCVJBRGKVKOYVXBEYUIGZGGLDCLYPNBRKKVOJAXTGDSDJMIHCHYFMCJKKIPDVJYYWEVRRUPURYZJZCZDDJGFFCKBRYJWBSQOXUWFVWSTVQKUWHEWOIHRQHKJJLYUIKOVRNKYCIJZQVLOGMKMJMQOJDVRKBCWBQSDOTKBFVRNBFJUFCSLPLTMZQRBQPQYYYHTTTSGRGYKJQUHEHHZZTDSSKBMHZQYSKMQYYCJGLGAVEYAZQHUEKQQHGKIQQHHGRTIICVIHNIGMIEPOJAGUTHDYLPVTATKFATYDHFIGKYFKWYHLVGXWJBFBLTPUTIZZMPAIYGIESDCUHZLJNWFZKOAFPIEZHBMMYWCGGESHKASYWTZGQMDBKMYZAVXGEZYBFSOEMTWMXAVDNROQEPZAFDBWRNIWVKVJCDMCIYJZHFJNJLYPKMNHVMWDDZGRDDSTCXVMDEKEGTMWQPMEYWMPKULVZHCSPWVFAXXSAGBUYVTGKALZWVNJCKVVYKLFRZFIYMZEGJNMBQTQGHNVWGAOEJVQKYJHDQBXGKTOTPRZZMWSPEMCSXNTADOYITCUEYFDDGAVELDTBFVHRWGZHNYRGOIBENWDRJKZDQBIXFARWKGNAGOMYTUBPLKKPJOPTCKNFMOHIGHXGMLHIYXCSFSJQRNDLTGPYQZTUMRIPJDZWTDHRTSJWUXVUDFMZNTXJVXXANZGIFUFGRMOENQJYFSRBTWLNRACHYGMUPDMHJHYWQVLMUAOXSWUFVCZOOYXQLIBYDFJUTFNVQDAKZSEITBDYMIJSFLDTRAYQSXQIGTZEUDKSUNURRJTYUTGRDGXDOWXIXHTWBSHHNLIVEGCAOTHRZOYEJWNBPQTYXXPKBYBHZBXZTOJYDESRWRWGTEDAODQDMQBIFQPOAMFMMMGBXAXANYEQRBOUUZPLXZHGOCYSMEFOQKTQJWDEZICCPKXLOHSVPJWQLIAZTEETFOVYPMSTHTASETJVORYGIPKKBSZRKPAQAROIKNYIGDPXZNNAGXQVDPQKQSZIJOFXQWMOFHHYCUUMTDJONADQGFYSEFGTIJJCJMAQCYFODKFYWTTNRYELAIQEBINRKOJNNFJVQKVUNFLEYUQFIAXLCJSYYISPFNMKGFOCWNIEQFLJOPEBWHWDIAMVFSDFRLQWJFZQETJICZWBLKOBDERKNPKDEYYXFPFUWURNVFFSWFJQCSSZDTOWZWWWKSVWEKLFGIFEAZOYOAWBOYWCONWQJAGCOZBPYWKRIKUOBPOJXSNXWYYFKZEOFHWRBKDFIIGYCINTGFGHYRBKMSGWXHZVABTNQYPOCNNWNFHBMTBGTJQURABVSPSSDVOWEAFMDKCFZQPSLOGFGKQZTPFKBIFIUPUGZOGTKHVQCQWRCTRNDYRPHRFDLEHPXYGDGOZIVKMWIQIYXBOFFBAQEMNNAEPBBGKNICAUIPYJKUNRHGKBQEEYJZEFWTFNHPKKYJPLCYPPSYGRMDIUDRLRULIZDQRDQGPFGCNXQMMCVAXDGTFWHEBGDSQVLCVVFKFYFLBVADTPOGEXSACHWLOLKSUWSMFOCPULZRZQBKLZVGQIQOIESAVHIRVDAZTMMBBWJVURPAZVVZNOQCLOHZYIPVWKWAVZSXDQPLZHOPJOLFVDWCSYIQOAEEXHPJTLWAPESKQAEEQNFYTWDFCJREHVFZRWNJPLBKLUHUEONBRAKVTLGRIEDUYLLXXDYVWJHLFCFQTFCJDJVOBVOMDAJVLVJDLRFANNWRXBUPDSWBLYTCUHWARAWOFMTIEARRWCWEWZGRYDWWRNNBGSZBRQWZVCCHPVRCZXMWQTSBBGIAOCPBZFOIZHMZBFLVQCMGUV"
	encoded := e.Encode(cipherText, "KSY")
	fmt.Printf("%q \n", encoded)

	/**
	 * END OF ENIGMA DECIPHER CODE
	 */
}
